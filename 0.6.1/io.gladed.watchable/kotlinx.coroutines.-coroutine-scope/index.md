[io.gladed.watchable](../index.md) / [kotlinx.coroutines.CoroutineScope](./index.md)

### Extensions for kotlinx.coroutines.CoroutineScope

| Name | Summary |
|---|---|
| [batch](batch.md) | `fun <T, C : `[`Change`](../-change.md)`<`[`T`](batch.md#T)`>> CoroutineScope.batch(watchable: `[`Watchable`](../-watchable/index.md)`<`[`T`](batch.md#T)`, `[`C`](batch.md#C)`>, minPeriod: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)` = 0, func: suspend (`[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`C`](batch.md#C)`>) -> `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`): Job`<br>Deliver multiple changes for this [Watchable](../-watchable/index.md) to [func](batch.md#io.gladed.watchable$batch(kotlinx.coroutines.CoroutineScope, io.gladed.watchable.Watchable((io.gladed.watchable.batch.T, io.gladed.watchable.batch.C)), kotlin.Long, kotlin.SuspendFunction1((kotlin.collections.List((io.gladed.watchable.batch.C)), kotlin.Unit)))/func), starting with its initial state, until the returned job is cancelled or this [CoroutineScope](#) completes.`fun <U> CoroutineScope.batch(input: ReceiveChannel<`[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`U`](batch.md#U)`>>, periodMillis: `[`Long`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-long/index.html)` = 0): ReceiveChannel<`[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`U`](batch.md#U)`>>`<br>For a given receive channel of lists of items, emit combined lists of items no more frequently than every [periodMillis](batch.md#io.gladed.watchable$batch(kotlinx.coroutines.CoroutineScope, kotlinx.coroutines.channels.ReceiveChannel((kotlin.collections.List((io.gladed.watchable.batch.U)))), kotlin.Long)/periodMillis), starting now. If [periodMillis](batch.md#io.gladed.watchable$batch(kotlinx.coroutines.CoroutineScope, kotlinx.coroutines.channels.ReceiveChannel((kotlin.collections.List((io.gladed.watchable.batch.U)))), kotlin.Long)/periodMillis) is non-positive, returns [input](batch.md#io.gladed.watchable$batch(kotlinx.coroutines.CoroutineScope, kotlinx.coroutines.channels.ReceiveChannel((kotlin.collections.List((io.gladed.watchable.batch.U)))), kotlin.Long)/input) as-is (unbatched). |
| [bind](bind.md) | `fun <T, M : `[`T`](bind.md#T)`, C : `[`Change`](../-change.md)`<`[`T`](bind.md#T)`>> CoroutineScope.bind(dest: `[`MutableWatchable`](../-mutable-watchable/index.md)`<`[`T`](bind.md#T)`, `[`M`](bind.md#M)`, `[`C`](bind.md#C)`>, origin: `[`Watchable`](../-watchable/index.md)`<`[`T`](bind.md#T)`, `[`C`](bind.md#C)`>): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Bind [dest](bind.md#io.gladed.watchable$bind(kotlinx.coroutines.CoroutineScope, io.gladed.watchable.MutableWatchable((io.gladed.watchable.bind.T, io.gladed.watchable.bind.M, io.gladed.watchable.bind.C)), io.gladed.watchable.Watchable((io.gladed.watchable.bind.T, io.gladed.watchable.bind.C)))/dest) so that it receives values from [origin](bind.md#io.gladed.watchable$bind(kotlinx.coroutines.CoroutineScope, io.gladed.watchable.MutableWatchable((io.gladed.watchable.bind.T, io.gladed.watchable.bind.M, io.gladed.watchable.bind.C)), io.gladed.watchable.Watchable((io.gladed.watchable.bind.T, io.gladed.watchable.bind.C)))/origin) as long as this [CoroutineScope](#) lives.`fun <T, M : `[`T`](bind.md#T)`, C : `[`Change`](../-change.md)`<`[`T`](bind.md#T)`>, T2, C2 : `[`Change`](../-change.md)`<`[`T2`](bind.md#T2)`>> CoroutineScope.bind(dest: `[`MutableWatchable`](../-mutable-watchable/index.md)`<`[`T`](bind.md#T)`, `[`M`](bind.md#M)`, `[`C`](bind.md#C)`>, origin: `[`Watchable`](../-watchable/index.md)`<`[`T2`](bind.md#T2)`, `[`C2`](bind.md#C2)`>, apply: `[`M`](bind.md#M)`.(`[`C2`](bind.md#C2)`) -> `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`): `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)<br>Bind [dest](bind.md#io.gladed.watchable$bind(kotlinx.coroutines.CoroutineScope, io.gladed.watchable.MutableWatchable((io.gladed.watchable.bind.T, io.gladed.watchable.bind.M, io.gladed.watchable.bind.C)), io.gladed.watchable.Watchable((io.gladed.watchable.bind.T2, io.gladed.watchable.bind.C2)), kotlin.Function2((io.gladed.watchable.bind.M, io.gladed.watchable.bind.C2, kotlin.Unit)))/dest) so that it receives changes from [origin](bind.md#io.gladed.watchable$bind(kotlinx.coroutines.CoroutineScope, io.gladed.watchable.MutableWatchable((io.gladed.watchable.bind.T, io.gladed.watchable.bind.M, io.gladed.watchable.bind.C)), io.gladed.watchable.Watchable((io.gladed.watchable.bind.T2, io.gladed.watchable.bind.C2)), kotlin.Function2((io.gladed.watchable.bind.M, io.gladed.watchable.bind.C2, kotlin.Unit)))/origin) and applies them with [apply](bind.md#io.gladed.watchable$bind(kotlinx.coroutines.CoroutineScope, io.gladed.watchable.MutableWatchable((io.gladed.watchable.bind.T, io.gladed.watchable.bind.M, io.gladed.watchable.bind.C)), io.gladed.watchable.Watchable((io.gladed.watchable.bind.T2, io.gladed.watchable.bind.C2)), kotlin.Function2((io.gladed.watchable.bind.M, io.gladed.watchable.bind.C2, kotlin.Unit)))/apply) for as long as this [CoroutineScope](#) lives. |
| [daemon](daemon.md) | `fun CoroutineScope.daemon(context: `[`CoroutineContext`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/index.html)` = EmptyCoroutineContext, block: suspend CoroutineScope.() -> `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`): Job`<br>Similar to [launch](#) but does not block parent's ability to [Job.join](#). Cancels when parent cancels. |
| [subscribe](subscribe.md) | `fun <T, C : `[`Change`](../-change.md)`<`[`T`](subscribe.md#T)`>> CoroutineScope.subscribe(target: `[`Watchable`](../-watchable/index.md)`<`[`T`](subscribe.md#T)`, `[`C`](subscribe.md#C)`>): ReceiveChannel<`[`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/index.html)`<`[`C`](subscribe.md#C)`>>`<br>Create a [ReceiveChannel](#) for intercepting lists of changes made to [target](subscribe.md#io.gladed.watchable$subscribe(kotlinx.coroutines.CoroutineScope, io.gladed.watchable.Watchable((io.gladed.watchable.subscribe.T, io.gladed.watchable.subscribe.C)))/target) for as long as this [CoroutineScope](#) lives. |
| [watch](watch.md) | `fun <T, C : `[`Change`](../-change.md)`<`[`T`](watch.md#T)`>> CoroutineScope.watch(watchable: `[`Watchable`](../-watchable/index.md)`<`[`T`](watch.md#T)`, `[`C`](watch.md#C)`>, func: suspend (`[`C`](watch.md#C)`) -> `[`Unit`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/index.html)`): Job`<br>Deliver changes for this [Watchable](../-watchable/index.md) to [func](watch.md#io.gladed.watchable$watch(kotlinx.coroutines.CoroutineScope, io.gladed.watchable.Watchable((io.gladed.watchable.watch.T, io.gladed.watchable.watch.C)), kotlin.SuspendFunction1((io.gladed.watchable.watch.C, kotlin.Unit)))/func), starting with its initial state, until the returned job is cancelled or this [CoroutineScope](#) completes. |
